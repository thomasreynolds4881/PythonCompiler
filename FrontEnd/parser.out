Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> LBRACE action_new_scope stmt_list RBRACE
Rule 3     action_new_scope -> <empty>
Rule 4     stmt_list -> stmt_list stmt
Rule 5     stmt_list -> <empty>
Rule 6     stmt -> type ID SEMICOLON
Rule 7     stmt -> ID ASSIGN expr SEMICOLON
Rule 8     stmt -> block
Rule 9     stmt -> READ ID SEMICOLON
Rule 10    stmt -> WRITE logicor SEMICOLON
Rule 11    stmt -> IF LPAREN logicor RPAREN block
Rule 12    stmt -> IF LPAREN logicor RPAREN block ELSE block
Rule 13    stmt -> WHILE LPAREN logicor RPAREN block
Rule 14    type -> INT
Rule 15    logicor -> logicor OR logicand
Rule 16    logicor -> logicand
Rule 17    logicand -> logicand AND compEq
Rule 18    logicand -> compEq
Rule 19    compEq -> compEq EQUALTO comp
Rule 20    compEq -> compEq NOTEQUALTO comp
Rule 21    compEq -> comp
Rule 22    comp -> comp LESSTHAN expr
Rule 23    comp -> comp LESSEQUALTO expr
Rule 24    comp -> comp GREATERTHAN expr
Rule 25    comp -> comp GREATEREQUALTO expr
Rule 26    comp -> expr
Rule 27    expr -> expr PLUS term
Rule 28    expr -> expr MINUS term
Rule 29    expr -> term
Rule 30    term -> term TIMES factor
Rule 31    term -> term DIVIDE factor
Rule 32    term -> term MODULO factor
Rule 33    term -> factor
Rule 34    factor -> MINUS factor
Rule 35    factor -> NOT factor
Rule 36    factor -> ID
Rule 37    factor -> NUM
Rule 38    factor -> LPAREN logicor RPAREN

Terminals, with rules where they appear

AND                  : 17
ASSIGN               : 7
DIVIDE               : 31
ELSE                 : 12
EQUALTO              : 19
GREATEREQUALTO       : 25
GREATERTHAN          : 24
ID                   : 6 7 9 36
IF                   : 11 12
INT                  : 14
LBRACE               : 2
LESSEQUALTO          : 23
LESSTHAN             : 22
LPAREN               : 11 12 13 38
MINUS                : 28 34
MODULO               : 32
NOT                  : 35
NOTEQUALTO           : 20
NUM                  : 37
OR                   : 15
PLUS                 : 27
RBRACE               : 2
READ                 : 9
RPAREN               : 11 12 13 38
SEMICOLON            : 6 7 9 10
TIMES                : 30
WHILE                : 13
WRITE                : 10
error                : 

Nonterminals, with rules where they appear

action_new_scope     : 2
block                : 1 8 11 12 12 13
comp                 : 19 20 21 22 23 24 25
compEq               : 17 18 19 20
expr                 : 7 22 23 24 25 26 27 28
factor               : 30 31 32 33 34 35
logicand             : 15 16 17
logicor              : 10 11 12 13 15 38
program              : 0
stmt                 : 4
stmt_list            : 2 4
term                 : 27 28 29 30 31 32
type                 : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . LBRACE action_new_scope stmt_list RBRACE

    LBRACE          shift and go to state 3

    program                        shift and go to state 1
    block                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> LBRACE . action_new_scope stmt_list RBRACE
    (3) action_new_scope -> .

    RBRACE          reduce using rule 3 (action_new_scope -> .)
    ID              reduce using rule 3 (action_new_scope -> .)
    READ            reduce using rule 3 (action_new_scope -> .)
    WRITE           reduce using rule 3 (action_new_scope -> .)
    IF              reduce using rule 3 (action_new_scope -> .)
    WHILE           reduce using rule 3 (action_new_scope -> .)
    INT             reduce using rule 3 (action_new_scope -> .)
    LBRACE          reduce using rule 3 (action_new_scope -> .)

    action_new_scope               shift and go to state 4

state 4

    (2) block -> LBRACE action_new_scope . stmt_list RBRACE
    (4) stmt_list -> . stmt_list stmt
    (5) stmt_list -> .

    RBRACE          reduce using rule 5 (stmt_list -> .)
    ID              reduce using rule 5 (stmt_list -> .)
    READ            reduce using rule 5 (stmt_list -> .)
    WRITE           reduce using rule 5 (stmt_list -> .)
    IF              reduce using rule 5 (stmt_list -> .)
    WHILE           reduce using rule 5 (stmt_list -> .)
    INT             reduce using rule 5 (stmt_list -> .)
    LBRACE          reduce using rule 5 (stmt_list -> .)

    stmt_list                      shift and go to state 5

state 5

    (2) block -> LBRACE action_new_scope stmt_list . RBRACE
    (4) stmt_list -> stmt_list . stmt
    (6) stmt -> . type ID SEMICOLON
    (7) stmt -> . ID ASSIGN expr SEMICOLON
    (8) stmt -> . block
    (9) stmt -> . READ ID SEMICOLON
    (10) stmt -> . WRITE logicor SEMICOLON
    (11) stmt -> . IF LPAREN logicor RPAREN block
    (12) stmt -> . IF LPAREN logicor RPAREN block ELSE block
    (13) stmt -> . WHILE LPAREN logicor RPAREN block
    (14) type -> . INT
    (2) block -> . LBRACE action_new_scope stmt_list RBRACE

    RBRACE          shift and go to state 6
    ID              shift and go to state 9
    READ            shift and go to state 11
    WRITE           shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    INT             shift and go to state 15
    LBRACE          shift and go to state 3

    stmt                           shift and go to state 7
    type                           shift and go to state 8
    block                          shift and go to state 10

state 6

    (2) block -> LBRACE action_new_scope stmt_list RBRACE .

    $end            reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    RBRACE          reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    ID              reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    READ            reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    WRITE           reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    IF              reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    WHILE           reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    INT             reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    LBRACE          reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)
    ELSE            reduce using rule 2 (block -> LBRACE action_new_scope stmt_list RBRACE .)


state 7

    (4) stmt_list -> stmt_list stmt .

    RBRACE          reduce using rule 4 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 4 (stmt_list -> stmt_list stmt .)
    READ            reduce using rule 4 (stmt_list -> stmt_list stmt .)
    WRITE           reduce using rule 4 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 4 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 4 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 4 (stmt_list -> stmt_list stmt .)
    LBRACE          reduce using rule 4 (stmt_list -> stmt_list stmt .)


state 8

    (6) stmt -> type . ID SEMICOLON

    ID              shift and go to state 16


state 9

    (7) stmt -> ID . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 17


state 10

    (8) stmt -> block .

    RBRACE          reduce using rule 8 (stmt -> block .)
    ID              reduce using rule 8 (stmt -> block .)
    READ            reduce using rule 8 (stmt -> block .)
    WRITE           reduce using rule 8 (stmt -> block .)
    IF              reduce using rule 8 (stmt -> block .)
    WHILE           reduce using rule 8 (stmt -> block .)
    INT             reduce using rule 8 (stmt -> block .)
    LBRACE          reduce using rule 8 (stmt -> block .)


state 11

    (9) stmt -> READ . ID SEMICOLON

    ID              shift and go to state 18


state 12

    (10) stmt -> WRITE . logicor SEMICOLON
    (15) logicor -> . logicor OR logicand
    (16) logicor -> . logicand
    (17) logicand -> . logicand AND compEq
    (18) logicand -> . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    logicor                        shift and go to state 19
    logicand                       shift and go to state 20
    compEq                         shift and go to state 21
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 13

    (11) stmt -> IF . LPAREN logicor RPAREN block
    (12) stmt -> IF . LPAREN logicor RPAREN block ELSE block

    LPAREN          shift and go to state 31


state 14

    (13) stmt -> WHILE . LPAREN logicor RPAREN block

    LPAREN          shift and go to state 32


state 15

    (14) type -> INT .

    ID              reduce using rule 14 (type -> INT .)


state 16

    (6) stmt -> type ID . SEMICOLON

    SEMICOLON       shift and go to state 33


state 17

    (7) stmt -> ID ASSIGN . expr SEMICOLON
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    expr                           shift and go to state 34
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 18

    (9) stmt -> READ ID . SEMICOLON

    SEMICOLON       shift and go to state 35


state 19

    (10) stmt -> WRITE logicor . SEMICOLON
    (15) logicor -> logicor . OR logicand

    SEMICOLON       shift and go to state 36
    OR              shift and go to state 37


state 20

    (16) logicor -> logicand .
    (17) logicand -> logicand . AND compEq

    SEMICOLON       reduce using rule 16 (logicor -> logicand .)
    OR              reduce using rule 16 (logicor -> logicand .)
    RPAREN          reduce using rule 16 (logicor -> logicand .)
    AND             shift and go to state 38


state 21

    (18) logicand -> compEq .
    (19) compEq -> compEq . EQUALTO comp
    (20) compEq -> compEq . NOTEQUALTO comp

    AND             reduce using rule 18 (logicand -> compEq .)
    SEMICOLON       reduce using rule 18 (logicand -> compEq .)
    OR              reduce using rule 18 (logicand -> compEq .)
    RPAREN          reduce using rule 18 (logicand -> compEq .)
    EQUALTO         shift and go to state 39
    NOTEQUALTO      shift and go to state 40


state 22

    (21) compEq -> comp .
    (22) comp -> comp . LESSTHAN expr
    (23) comp -> comp . LESSEQUALTO expr
    (24) comp -> comp . GREATERTHAN expr
    (25) comp -> comp . GREATEREQUALTO expr

    EQUALTO         reduce using rule 21 (compEq -> comp .)
    NOTEQUALTO      reduce using rule 21 (compEq -> comp .)
    AND             reduce using rule 21 (compEq -> comp .)
    SEMICOLON       reduce using rule 21 (compEq -> comp .)
    OR              reduce using rule 21 (compEq -> comp .)
    RPAREN          reduce using rule 21 (compEq -> comp .)
    LESSTHAN        shift and go to state 41
    LESSEQUALTO     shift and go to state 42
    GREATERTHAN     shift and go to state 43
    GREATEREQUALTO  shift and go to state 44


state 23

    (26) comp -> expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LESSTHAN        reduce using rule 26 (comp -> expr .)
    LESSEQUALTO     reduce using rule 26 (comp -> expr .)
    GREATERTHAN     reduce using rule 26 (comp -> expr .)
    GREATEREQUALTO  reduce using rule 26 (comp -> expr .)
    EQUALTO         reduce using rule 26 (comp -> expr .)
    NOTEQUALTO      reduce using rule 26 (comp -> expr .)
    AND             reduce using rule 26 (comp -> expr .)
    SEMICOLON       reduce using rule 26 (comp -> expr .)
    OR              reduce using rule 26 (comp -> expr .)
    RPAREN          reduce using rule 26 (comp -> expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 24

    (29) expr -> term .
    (30) term -> term . TIMES factor
    (31) term -> term . DIVIDE factor
    (32) term -> term . MODULO factor

    PLUS            reduce using rule 29 (expr -> term .)
    MINUS           reduce using rule 29 (expr -> term .)
    LESSTHAN        reduce using rule 29 (expr -> term .)
    LESSEQUALTO     reduce using rule 29 (expr -> term .)
    GREATERTHAN     reduce using rule 29 (expr -> term .)
    GREATEREQUALTO  reduce using rule 29 (expr -> term .)
    EQUALTO         reduce using rule 29 (expr -> term .)
    NOTEQUALTO      reduce using rule 29 (expr -> term .)
    AND             reduce using rule 29 (expr -> term .)
    SEMICOLON       reduce using rule 29 (expr -> term .)
    OR              reduce using rule 29 (expr -> term .)
    RPAREN          reduce using rule 29 (expr -> term .)
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MODULO          shift and go to state 49


state 25

    (34) factor -> MINUS . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    factor                         shift and go to state 50

state 26

    (33) term -> factor .

    TIMES           reduce using rule 33 (term -> factor .)
    DIVIDE          reduce using rule 33 (term -> factor .)
    MODULO          reduce using rule 33 (term -> factor .)
    PLUS            reduce using rule 33 (term -> factor .)
    MINUS           reduce using rule 33 (term -> factor .)
    LESSTHAN        reduce using rule 33 (term -> factor .)
    LESSEQUALTO     reduce using rule 33 (term -> factor .)
    GREATERTHAN     reduce using rule 33 (term -> factor .)
    GREATEREQUALTO  reduce using rule 33 (term -> factor .)
    EQUALTO         reduce using rule 33 (term -> factor .)
    NOTEQUALTO      reduce using rule 33 (term -> factor .)
    AND             reduce using rule 33 (term -> factor .)
    SEMICOLON       reduce using rule 33 (term -> factor .)
    OR              reduce using rule 33 (term -> factor .)
    RPAREN          reduce using rule 33 (term -> factor .)


state 27

    (35) factor -> NOT . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    factor                         shift and go to state 51

state 28

    (36) factor -> ID .

    TIMES           reduce using rule 36 (factor -> ID .)
    DIVIDE          reduce using rule 36 (factor -> ID .)
    MODULO          reduce using rule 36 (factor -> ID .)
    PLUS            reduce using rule 36 (factor -> ID .)
    MINUS           reduce using rule 36 (factor -> ID .)
    LESSTHAN        reduce using rule 36 (factor -> ID .)
    LESSEQUALTO     reduce using rule 36 (factor -> ID .)
    GREATERTHAN     reduce using rule 36 (factor -> ID .)
    GREATEREQUALTO  reduce using rule 36 (factor -> ID .)
    EQUALTO         reduce using rule 36 (factor -> ID .)
    NOTEQUALTO      reduce using rule 36 (factor -> ID .)
    AND             reduce using rule 36 (factor -> ID .)
    SEMICOLON       reduce using rule 36 (factor -> ID .)
    OR              reduce using rule 36 (factor -> ID .)
    RPAREN          reduce using rule 36 (factor -> ID .)


state 29

    (37) factor -> NUM .

    TIMES           reduce using rule 37 (factor -> NUM .)
    DIVIDE          reduce using rule 37 (factor -> NUM .)
    MODULO          reduce using rule 37 (factor -> NUM .)
    PLUS            reduce using rule 37 (factor -> NUM .)
    MINUS           reduce using rule 37 (factor -> NUM .)
    LESSTHAN        reduce using rule 37 (factor -> NUM .)
    LESSEQUALTO     reduce using rule 37 (factor -> NUM .)
    GREATERTHAN     reduce using rule 37 (factor -> NUM .)
    GREATEREQUALTO  reduce using rule 37 (factor -> NUM .)
    EQUALTO         reduce using rule 37 (factor -> NUM .)
    NOTEQUALTO      reduce using rule 37 (factor -> NUM .)
    AND             reduce using rule 37 (factor -> NUM .)
    SEMICOLON       reduce using rule 37 (factor -> NUM .)
    OR              reduce using rule 37 (factor -> NUM .)
    RPAREN          reduce using rule 37 (factor -> NUM .)


state 30

    (38) factor -> LPAREN . logicor RPAREN
    (15) logicor -> . logicor OR logicand
    (16) logicor -> . logicand
    (17) logicand -> . logicand AND compEq
    (18) logicand -> . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    logicor                        shift and go to state 52
    logicand                       shift and go to state 20
    compEq                         shift and go to state 21
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 31

    (11) stmt -> IF LPAREN . logicor RPAREN block
    (12) stmt -> IF LPAREN . logicor RPAREN block ELSE block
    (15) logicor -> . logicor OR logicand
    (16) logicor -> . logicand
    (17) logicand -> . logicand AND compEq
    (18) logicand -> . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    logicor                        shift and go to state 53
    logicand                       shift and go to state 20
    compEq                         shift and go to state 21
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 32

    (13) stmt -> WHILE LPAREN . logicor RPAREN block
    (15) logicor -> . logicor OR logicand
    (16) logicor -> . logicand
    (17) logicand -> . logicand AND compEq
    (18) logicand -> . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    logicor                        shift and go to state 54
    logicand                       shift and go to state 20
    compEq                         shift and go to state 21
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 33

    (6) stmt -> type ID SEMICOLON .

    RBRACE          reduce using rule 6 (stmt -> type ID SEMICOLON .)
    ID              reduce using rule 6 (stmt -> type ID SEMICOLON .)
    READ            reduce using rule 6 (stmt -> type ID SEMICOLON .)
    WRITE           reduce using rule 6 (stmt -> type ID SEMICOLON .)
    IF              reduce using rule 6 (stmt -> type ID SEMICOLON .)
    WHILE           reduce using rule 6 (stmt -> type ID SEMICOLON .)
    INT             reduce using rule 6 (stmt -> type ID SEMICOLON .)
    LBRACE          reduce using rule 6 (stmt -> type ID SEMICOLON .)


state 34

    (7) stmt -> ID ASSIGN expr . SEMICOLON
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 55
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 35

    (9) stmt -> READ ID SEMICOLON .

    RBRACE          reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    ID              reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    READ            reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    WRITE           reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    IF              reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    WHILE           reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    INT             reduce using rule 9 (stmt -> READ ID SEMICOLON .)
    LBRACE          reduce using rule 9 (stmt -> READ ID SEMICOLON .)


state 36

    (10) stmt -> WRITE logicor SEMICOLON .

    RBRACE          reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    ID              reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    READ            reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    WRITE           reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    IF              reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    WHILE           reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    INT             reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)
    LBRACE          reduce using rule 10 (stmt -> WRITE logicor SEMICOLON .)


state 37

    (15) logicor -> logicor OR . logicand
    (17) logicand -> . logicand AND compEq
    (18) logicand -> . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    logicand                       shift and go to state 56
    compEq                         shift and go to state 21
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 38

    (17) logicand -> logicand AND . compEq
    (19) compEq -> . compEq EQUALTO comp
    (20) compEq -> . compEq NOTEQUALTO comp
    (21) compEq -> . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    compEq                         shift and go to state 57
    comp                           shift and go to state 22
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 39

    (19) compEq -> compEq EQUALTO . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    comp                           shift and go to state 58
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 40

    (20) compEq -> compEq NOTEQUALTO . comp
    (22) comp -> . comp LESSTHAN expr
    (23) comp -> . comp LESSEQUALTO expr
    (24) comp -> . comp GREATERTHAN expr
    (25) comp -> . comp GREATEREQUALTO expr
    (26) comp -> . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    comp                           shift and go to state 59
    expr                           shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 41

    (22) comp -> comp LESSTHAN . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    expr                           shift and go to state 60
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 42

    (23) comp -> comp LESSEQUALTO . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    expr                           shift and go to state 61
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 43

    (24) comp -> comp GREATERTHAN . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    expr                           shift and go to state 62
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 44

    (25) comp -> comp GREATEREQUALTO . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    expr                           shift and go to state 63
    term                           shift and go to state 24
    factor                         shift and go to state 26

state 45

    (27) expr -> expr PLUS . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    term                           shift and go to state 64
    factor                         shift and go to state 26

state 46

    (28) expr -> expr MINUS . term
    (30) term -> . term TIMES factor
    (31) term -> . term DIVIDE factor
    (32) term -> . term MODULO factor
    (33) term -> . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    term                           shift and go to state 65
    factor                         shift and go to state 26

state 47

    (30) term -> term TIMES . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    factor                         shift and go to state 66

state 48

    (31) term -> term DIVIDE . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    factor                         shift and go to state 67

state 49

    (32) term -> term MODULO . factor
    (34) factor -> . MINUS factor
    (35) factor -> . NOT factor
    (36) factor -> . ID
    (37) factor -> . NUM
    (38) factor -> . LPAREN logicor RPAREN

    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    ID              shift and go to state 28
    NUM             shift and go to state 29
    LPAREN          shift and go to state 30

    factor                         shift and go to state 68

state 50

    (34) factor -> MINUS factor .

    TIMES           reduce using rule 34 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 34 (factor -> MINUS factor .)
    MODULO          reduce using rule 34 (factor -> MINUS factor .)
    PLUS            reduce using rule 34 (factor -> MINUS factor .)
    MINUS           reduce using rule 34 (factor -> MINUS factor .)
    LESSTHAN        reduce using rule 34 (factor -> MINUS factor .)
    LESSEQUALTO     reduce using rule 34 (factor -> MINUS factor .)
    GREATERTHAN     reduce using rule 34 (factor -> MINUS factor .)
    GREATEREQUALTO  reduce using rule 34 (factor -> MINUS factor .)
    EQUALTO         reduce using rule 34 (factor -> MINUS factor .)
    NOTEQUALTO      reduce using rule 34 (factor -> MINUS factor .)
    AND             reduce using rule 34 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 34 (factor -> MINUS factor .)
    OR              reduce using rule 34 (factor -> MINUS factor .)
    RPAREN          reduce using rule 34 (factor -> MINUS factor .)


state 51

    (35) factor -> NOT factor .

    TIMES           reduce using rule 35 (factor -> NOT factor .)
    DIVIDE          reduce using rule 35 (factor -> NOT factor .)
    MODULO          reduce using rule 35 (factor -> NOT factor .)
    PLUS            reduce using rule 35 (factor -> NOT factor .)
    MINUS           reduce using rule 35 (factor -> NOT factor .)
    LESSTHAN        reduce using rule 35 (factor -> NOT factor .)
    LESSEQUALTO     reduce using rule 35 (factor -> NOT factor .)
    GREATERTHAN     reduce using rule 35 (factor -> NOT factor .)
    GREATEREQUALTO  reduce using rule 35 (factor -> NOT factor .)
    EQUALTO         reduce using rule 35 (factor -> NOT factor .)
    NOTEQUALTO      reduce using rule 35 (factor -> NOT factor .)
    AND             reduce using rule 35 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 35 (factor -> NOT factor .)
    OR              reduce using rule 35 (factor -> NOT factor .)
    RPAREN          reduce using rule 35 (factor -> NOT factor .)


state 52

    (38) factor -> LPAREN logicor . RPAREN
    (15) logicor -> logicor . OR logicand

    RPAREN          shift and go to state 69
    OR              shift and go to state 37


state 53

    (11) stmt -> IF LPAREN logicor . RPAREN block
    (12) stmt -> IF LPAREN logicor . RPAREN block ELSE block
    (15) logicor -> logicor . OR logicand

    RPAREN          shift and go to state 70
    OR              shift and go to state 37


state 54

    (13) stmt -> WHILE LPAREN logicor . RPAREN block
    (15) logicor -> logicor . OR logicand

    RPAREN          shift and go to state 71
    OR              shift and go to state 37


state 55

    (7) stmt -> ID ASSIGN expr SEMICOLON .

    RBRACE          reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    READ            reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    WRITE           reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    INT             reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 7 (stmt -> ID ASSIGN expr SEMICOLON .)


state 56

    (15) logicor -> logicor OR logicand .
    (17) logicand -> logicand . AND compEq

    SEMICOLON       reduce using rule 15 (logicor -> logicor OR logicand .)
    OR              reduce using rule 15 (logicor -> logicor OR logicand .)
    RPAREN          reduce using rule 15 (logicor -> logicor OR logicand .)
    AND             shift and go to state 38


state 57

    (17) logicand -> logicand AND compEq .
    (19) compEq -> compEq . EQUALTO comp
    (20) compEq -> compEq . NOTEQUALTO comp

    AND             reduce using rule 17 (logicand -> logicand AND compEq .)
    SEMICOLON       reduce using rule 17 (logicand -> logicand AND compEq .)
    OR              reduce using rule 17 (logicand -> logicand AND compEq .)
    RPAREN          reduce using rule 17 (logicand -> logicand AND compEq .)
    EQUALTO         shift and go to state 39
    NOTEQUALTO      shift and go to state 40


state 58

    (19) compEq -> compEq EQUALTO comp .
    (22) comp -> comp . LESSTHAN expr
    (23) comp -> comp . LESSEQUALTO expr
    (24) comp -> comp . GREATERTHAN expr
    (25) comp -> comp . GREATEREQUALTO expr

    EQUALTO         reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    NOTEQUALTO      reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    AND             reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    SEMICOLON       reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    OR              reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    RPAREN          reduce using rule 19 (compEq -> compEq EQUALTO comp .)
    LESSTHAN        shift and go to state 41
    LESSEQUALTO     shift and go to state 42
    GREATERTHAN     shift and go to state 43
    GREATEREQUALTO  shift and go to state 44


state 59

    (20) compEq -> compEq NOTEQUALTO comp .
    (22) comp -> comp . LESSTHAN expr
    (23) comp -> comp . LESSEQUALTO expr
    (24) comp -> comp . GREATERTHAN expr
    (25) comp -> comp . GREATEREQUALTO expr

    EQUALTO         reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    NOTEQUALTO      reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    AND             reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    SEMICOLON       reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    OR              reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    RPAREN          reduce using rule 20 (compEq -> compEq NOTEQUALTO comp .)
    LESSTHAN        shift and go to state 41
    LESSEQUALTO     shift and go to state 42
    GREATERTHAN     shift and go to state 43
    GREATEREQUALTO  shift and go to state 44


state 60

    (22) comp -> comp LESSTHAN expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LESSTHAN        reduce using rule 22 (comp -> comp LESSTHAN expr .)
    LESSEQUALTO     reduce using rule 22 (comp -> comp LESSTHAN expr .)
    GREATERTHAN     reduce using rule 22 (comp -> comp LESSTHAN expr .)
    GREATEREQUALTO  reduce using rule 22 (comp -> comp LESSTHAN expr .)
    EQUALTO         reduce using rule 22 (comp -> comp LESSTHAN expr .)
    NOTEQUALTO      reduce using rule 22 (comp -> comp LESSTHAN expr .)
    AND             reduce using rule 22 (comp -> comp LESSTHAN expr .)
    SEMICOLON       reduce using rule 22 (comp -> comp LESSTHAN expr .)
    OR              reduce using rule 22 (comp -> comp LESSTHAN expr .)
    RPAREN          reduce using rule 22 (comp -> comp LESSTHAN expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 61

    (23) comp -> comp LESSEQUALTO expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LESSTHAN        reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    LESSEQUALTO     reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    GREATERTHAN     reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    GREATEREQUALTO  reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    EQUALTO         reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    NOTEQUALTO      reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    AND             reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    SEMICOLON       reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    OR              reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    RPAREN          reduce using rule 23 (comp -> comp LESSEQUALTO expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 62

    (24) comp -> comp GREATERTHAN expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LESSTHAN        reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    LESSEQUALTO     reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    GREATERTHAN     reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    GREATEREQUALTO  reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    EQUALTO         reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    NOTEQUALTO      reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    AND             reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    SEMICOLON       reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    OR              reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    RPAREN          reduce using rule 24 (comp -> comp GREATERTHAN expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 63

    (25) comp -> comp GREATEREQUALTO expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LESSTHAN        reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    LESSEQUALTO     reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    GREATERTHAN     reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    GREATEREQUALTO  reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    EQUALTO         reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    NOTEQUALTO      reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    AND             reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    SEMICOLON       reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    OR              reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    RPAREN          reduce using rule 25 (comp -> comp GREATEREQUALTO expr .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 64

    (27) expr -> expr PLUS term .
    (30) term -> term . TIMES factor
    (31) term -> term . DIVIDE factor
    (32) term -> term . MODULO factor

    PLUS            reduce using rule 27 (expr -> expr PLUS term .)
    MINUS           reduce using rule 27 (expr -> expr PLUS term .)
    LESSTHAN        reduce using rule 27 (expr -> expr PLUS term .)
    LESSEQUALTO     reduce using rule 27 (expr -> expr PLUS term .)
    GREATERTHAN     reduce using rule 27 (expr -> expr PLUS term .)
    GREATEREQUALTO  reduce using rule 27 (expr -> expr PLUS term .)
    EQUALTO         reduce using rule 27 (expr -> expr PLUS term .)
    NOTEQUALTO      reduce using rule 27 (expr -> expr PLUS term .)
    AND             reduce using rule 27 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 27 (expr -> expr PLUS term .)
    OR              reduce using rule 27 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 27 (expr -> expr PLUS term .)
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MODULO          shift and go to state 49


state 65

    (28) expr -> expr MINUS term .
    (30) term -> term . TIMES factor
    (31) term -> term . DIVIDE factor
    (32) term -> term . MODULO factor

    PLUS            reduce using rule 28 (expr -> expr MINUS term .)
    MINUS           reduce using rule 28 (expr -> expr MINUS term .)
    LESSTHAN        reduce using rule 28 (expr -> expr MINUS term .)
    LESSEQUALTO     reduce using rule 28 (expr -> expr MINUS term .)
    GREATERTHAN     reduce using rule 28 (expr -> expr MINUS term .)
    GREATEREQUALTO  reduce using rule 28 (expr -> expr MINUS term .)
    EQUALTO         reduce using rule 28 (expr -> expr MINUS term .)
    NOTEQUALTO      reduce using rule 28 (expr -> expr MINUS term .)
    AND             reduce using rule 28 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 28 (expr -> expr MINUS term .)
    OR              reduce using rule 28 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 28 (expr -> expr MINUS term .)
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    MODULO          shift and go to state 49


state 66

    (30) term -> term TIMES factor .

    TIMES           reduce using rule 30 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 30 (term -> term TIMES factor .)
    MODULO          reduce using rule 30 (term -> term TIMES factor .)
    PLUS            reduce using rule 30 (term -> term TIMES factor .)
    MINUS           reduce using rule 30 (term -> term TIMES factor .)
    LESSTHAN        reduce using rule 30 (term -> term TIMES factor .)
    LESSEQUALTO     reduce using rule 30 (term -> term TIMES factor .)
    GREATERTHAN     reduce using rule 30 (term -> term TIMES factor .)
    GREATEREQUALTO  reduce using rule 30 (term -> term TIMES factor .)
    EQUALTO         reduce using rule 30 (term -> term TIMES factor .)
    NOTEQUALTO      reduce using rule 30 (term -> term TIMES factor .)
    AND             reduce using rule 30 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 30 (term -> term TIMES factor .)
    OR              reduce using rule 30 (term -> term TIMES factor .)
    RPAREN          reduce using rule 30 (term -> term TIMES factor .)


state 67

    (31) term -> term DIVIDE factor .

    TIMES           reduce using rule 31 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 31 (term -> term DIVIDE factor .)
    MODULO          reduce using rule 31 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 31 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 31 (term -> term DIVIDE factor .)
    LESSTHAN        reduce using rule 31 (term -> term DIVIDE factor .)
    LESSEQUALTO     reduce using rule 31 (term -> term DIVIDE factor .)
    GREATERTHAN     reduce using rule 31 (term -> term DIVIDE factor .)
    GREATEREQUALTO  reduce using rule 31 (term -> term DIVIDE factor .)
    EQUALTO         reduce using rule 31 (term -> term DIVIDE factor .)
    NOTEQUALTO      reduce using rule 31 (term -> term DIVIDE factor .)
    AND             reduce using rule 31 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 31 (term -> term DIVIDE factor .)
    OR              reduce using rule 31 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 31 (term -> term DIVIDE factor .)


state 68

    (32) term -> term MODULO factor .

    TIMES           reduce using rule 32 (term -> term MODULO factor .)
    DIVIDE          reduce using rule 32 (term -> term MODULO factor .)
    MODULO          reduce using rule 32 (term -> term MODULO factor .)
    PLUS            reduce using rule 32 (term -> term MODULO factor .)
    MINUS           reduce using rule 32 (term -> term MODULO factor .)
    LESSTHAN        reduce using rule 32 (term -> term MODULO factor .)
    LESSEQUALTO     reduce using rule 32 (term -> term MODULO factor .)
    GREATERTHAN     reduce using rule 32 (term -> term MODULO factor .)
    GREATEREQUALTO  reduce using rule 32 (term -> term MODULO factor .)
    EQUALTO         reduce using rule 32 (term -> term MODULO factor .)
    NOTEQUALTO      reduce using rule 32 (term -> term MODULO factor .)
    AND             reduce using rule 32 (term -> term MODULO factor .)
    SEMICOLON       reduce using rule 32 (term -> term MODULO factor .)
    OR              reduce using rule 32 (term -> term MODULO factor .)
    RPAREN          reduce using rule 32 (term -> term MODULO factor .)


state 69

    (38) factor -> LPAREN logicor RPAREN .

    TIMES           reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    DIVIDE          reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    MODULO          reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    PLUS            reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    MINUS           reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    LESSTHAN        reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    LESSEQUALTO     reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    GREATERTHAN     reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    GREATEREQUALTO  reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    EQUALTO         reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    NOTEQUALTO      reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    AND             reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    SEMICOLON       reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    OR              reduce using rule 38 (factor -> LPAREN logicor RPAREN .)
    RPAREN          reduce using rule 38 (factor -> LPAREN logicor RPAREN .)


state 70

    (11) stmt -> IF LPAREN logicor RPAREN . block
    (12) stmt -> IF LPAREN logicor RPAREN . block ELSE block
    (2) block -> . LBRACE action_new_scope stmt_list RBRACE

    LBRACE          shift and go to state 3

    block                          shift and go to state 72

state 71

    (13) stmt -> WHILE LPAREN logicor RPAREN . block
    (2) block -> . LBRACE action_new_scope stmt_list RBRACE

    LBRACE          shift and go to state 3

    block                          shift and go to state 73

state 72

    (11) stmt -> IF LPAREN logicor RPAREN block .
    (12) stmt -> IF LPAREN logicor RPAREN block . ELSE block

    RBRACE          reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    ID              reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    READ            reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    WRITE           reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    IF              reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    WHILE           reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    INT             reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    LBRACE          reduce using rule 11 (stmt -> IF LPAREN logicor RPAREN block .)
    ELSE            shift and go to state 74


state 73

    (13) stmt -> WHILE LPAREN logicor RPAREN block .

    RBRACE          reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    ID              reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    READ            reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    WRITE           reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    IF              reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    WHILE           reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    INT             reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)
    LBRACE          reduce using rule 13 (stmt -> WHILE LPAREN logicor RPAREN block .)


state 74

    (12) stmt -> IF LPAREN logicor RPAREN block ELSE . block
    (2) block -> . LBRACE action_new_scope stmt_list RBRACE

    LBRACE          shift and go to state 3

    block                          shift and go to state 75

state 75

    (12) stmt -> IF LPAREN logicor RPAREN block ELSE block .

    RBRACE          reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    ID              reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    READ            reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    WRITE           reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    IF              reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    WHILE           reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    INT             reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)
    LBRACE          reduce using rule 12 (stmt -> IF LPAREN logicor RPAREN block ELSE block .)

